import 'aframe';
import 'aframe-extras';
import 'aframe-forcegraph-component';
import Kapsule from 'kapsule';

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".graph-nav-info {\n  position: absolute;\n  bottom: 5px;\n  width: 100%;\n  text-align: center;\n  color: slategrey;\n  opacity: 0.7;\n  font-size: 10px;\n  font-family: Sans-serif;\n  z-index: 1000;\n}";
styleInject(css);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var _3dForceGraphVr = Kapsule({
  props: {
    width: {
      "default": window.innerWidth,
      triggerUpdate: false,
      onChange: function onChange(width, state) {
        if (state.container) state.container.style.width = width;
      }
    },
    height: {
      "default": window.innerHeight,
      triggerUpdate: false,
      onChange: function onChange(height, state) {
        if (state.container) state.container.style.height = height;
      }
    },
    jsonUrl: {},
    graphData: {
      "default": {
        nodes: [],
        links: []
      }
    },
    numDimensions: {
      "default": 3
    },
    dagMode: {},
    dagLevelDistance: {},
    backgroundColor: {
      "default": '#002'
    },
    showNavInfo: {
      "default": true
    },
    nodeRelSize: {
      "default": 4
    },
    // volume per val unit
    nodeId: {
      "default": 'id'
    },
    nodeLabel: {
      "default": 'name'
    },
    nodeDesc: {
      "default": 'desc'
    },
    nodeVal: {
      "default": 'val'
    },
    nodeResolution: {
      "default": 8
    },
    // how many slice segments in the sphere's circumference
    nodeColor: {
      "default": 'color'
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      "default": 0.75
    },
    nodeThreeObject: {},
    linkSource: {
      "default": 'source'
    },
    linkTarget: {
      "default": 'target'
    },
    linkLabel: {
      "default": 'name'
    },
    linkDesc: {
      "default": 'desc'
    },
    linkHoverPrecision: {
      "default": 2
    },
    linkVisibility: {
      "default": true
    },
    linkColor: {
      "default": 'color'
    },
    linkAutoColorBy: {},
    linkOpacity: {
      "default": 0.2
    },
    linkWidth: {
      "default": 0
    },
    linkResolution: {
      "default": 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      "default": 0
    },
    linkCurveRotation: {
      "default": 0
    },
    linkMaterial: {},
    linkThreeObject: {},
    linkPositionUpdate: {},
    linkDirectionalArrowLength: {
      "default": 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      "default": 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      "default": 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      "default": 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      "default": 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      "default": 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      "default": 4
    },
    // how many slice segments in the particle sphere's circumference
    forceEngine: {
      "default": 'd3'
    },
    // d3 or ngraph
    d3AlphaDecay: {
      "default": 0.0228
    },
    d3VelocityDecay: {
      "default": 0.4
    },
    warmupTicks: {
      "default": 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {},
    cooldownTime: {
      "default": 15000
    },
    // ms
    onEngineTick: {},
    onEngineStop: {}
  },
  methods: {
    d3Force: function d3Force(state) {
      var aframeComp = state.forcegraph.components.forcegraph;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var returnVal = aframeComp.d3Force.apply(aframeComp, args);
      return returnVal === aframeComp ? this // chain based on this object, not the inner aframe component
      : returnVal;
    },
    refresh: function refresh(state) {
      state.forcegraph.components.forcegraph.refresh();
      return this;
    },
    _destructor: function _destructor() {
      this.graphData({
        nodes: [],
        links: []
      });
    }
  },
  aliases: {
    // Prop names supported for backwards compatibility
    nameField: 'nodeLabel',
    idField: 'nodeId',
    valField: 'nodeVal',
    colorField: 'nodeColor',
    autoColorBy: 'nodeAutoColorBy',
    linkSourceField: 'linkSource',
    linkTargetField: 'linkTarget',
    linkColorField: 'linkColor',
    lineOpacity: 'linkOpacity'
  },
  init: function init(domNode, state) {
    // Wipe DOM
    domNode.innerHTML = '';
    state.container = document.createElement('div');
    domNode.appendChild(state.container);
    state.container.style.position = 'relative';
    state.container.style.width = state.width;
    state.container.style.height = state.height; // Add nav info section

    state.container.appendChild(state.navInfo = document.createElement('div'));
    state.navInfo.className = 'graph-nav-info';
    state.navInfo.textContent = 'Mouse drag: look, gamepad/arrow/wasd keys: move'; // Create scene

    var scene = document.createElement('a-scene');
    scene.setAttribute('embedded', ''); //scene.setAttribute('stats', null);

    scene.appendChild(state.sky = document.createElement('a-sky')); // Add camera and cursor

    var cameraG;
    scene.appendChild(cameraG = document.createElement('a-entity'));
    cameraG.setAttribute('position', '0 0 300');
    cameraG.setAttribute('movement-controls', 'fly: true; speed: 7');
    var camera;
    cameraG.appendChild(camera = document.createElement('a-entity'));
    camera.setAttribute('camera', '');
    camera.setAttribute('position', '0 0.001 0');
    camera.setAttribute('look-controls', 'reverseMouseDrag: false; pointerLockEnabled: true');
    var cursor;
    camera.appendChild(cursor = document.createElement('a-cursor'));
    cursor.setAttribute('color', 'lavender');
    cursor.setAttribute('opacity', 0.5);
    cursor.setAttribute('raycaster', 'objects: ----none----'); // disable cursor raycaster
    // Add forcegraph entity

    scene.appendChild(state.forcegraph = document.createElement('a-entity'));
    state.forcegraph.setAttribute('forcegraph', null); // attach scene

    state.container.appendChild(scene);
  },
  update: function update(state) {
    state.sky.setAttribute('color', state.backgroundColor);
    state.navInfo.style.display = state.showNavInfo ? null : 'none';
    var passThroughProps = ['jsonUrl', 'numDimensions', 'dagMode', 'dagLevelDistance', 'nodeRelSize', 'nodeId', 'nodeLabel', 'nodeDesc', 'nodeVal', 'nodeResolution', 'nodeColor', 'nodeAutoColorBy', 'nodeOpacity', 'nodeThreeObject', 'linkSource', 'linkTarget', 'linkLabel', 'linkDesc', 'linkHoverPrecision', 'linkVisibility', 'linkColor', 'linkAutoColorBy', 'linkOpacity', 'linkWidth', 'linkResolution', 'linkCurvature', 'linkCurveRotation', 'linkMaterial', 'linkThreeObject', 'linkPositionUpdate', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalArrowResolution', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleResolution', 'forceEngine', 'd3AlphaDecay', 'd3VelocityDecay', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'];
    var newProps = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(state).filter(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          prop = _ref2[0],
          val = _ref2[1];

      return passThroughProps.indexOf(prop) != -1 && val !== undefined && val !== null;
    }).map(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          val = _ref4[1];

      return _defineProperty({}, key, serialize(val));
    })), _toConsumableArray(Object.entries(state.graphData).map(function (_ref6) {
      var _ref7 = _slicedToArray(_ref6, 2),
          key = _ref7[0],
          val = _ref7[1];

      return _defineProperty({}, key, JSON.stringify(val));
    }))));
    state.forcegraph.setAttribute('forcegraph', newProps, true); //

    function serialize(p) {
      return p instanceof Function ? p.toString() : p; // convert functions to strings
    }
  }
});

export default _3dForceGraphVr;
